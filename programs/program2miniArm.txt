mov r0 8 //Set min and max MSB and LSB
shift r0 -3 //64
mov r1 0
str r1 r0 2 //store minMSB in 66
str r1 r0 3 //store minLSB in 67
mov r1 4
add r0 r1 //r0 = 68
mov r1 0
str r1 r0 0 //store maxMSB in 68
str r1 r0 1 //store maxLSB in 69
str r1 r0 2 //i = 0 //Use memory slot 70 and 71 for i and j
mov r0 9 //SETTING j = i+2
shift r0 -3 // 68
ldr r1 r0 2//get value of i
add2 r1
str r1 r0 3 //j = i+2
mov r0 8 //INSIDE J LOOP
shift r0 -4 //create sign mask
mov r1 9 //Loading in arr[i] arr[j]
shift r1 -3 //68
ldr r2 r1 0 //r2 holds I
ldr r3 r1 1 //r3 holds j
ldr r2 r2 0 //r2 holds arr[i]
ldr r3 r3 0 //r3 holds arr[j]
and r2 r2 r0 //signA
and r3 r3 r0 //signB
cmp r2 r3 //compare sign bits
//gen jump number using r3 and r2
//preserve the 68 in r1
bne r3 //if signA != signB skip down ??? lines to line #91 
add2 r1 //r1=70 IF THE SIGNS ARE EQUAL: //GOAL: subtract (16 bit subtraction) one from the other
ldr r1 r1 1 //load in r1=j
ldr r1 r1 1 //load in mem[j+1]
mov r0 0
sub1 r0 //setting r0=11111111
xor r1 r0 r1 //flip all bits
add1 r1 //flipped sign of mem[j+1]
bof r0 //if we have overflow, branch to overflow error handling
mov r0 8 //if we have no overflow
shift r0 -3 //64
mov r1 7
add r0 r1//r0=71
ldr r1 r0 1 //load in r1=j
ldr r2 r0 0 //load in r2=i
ldr r1 r1 0 //load in r1=mem[j]
ldr r2 r2 0 //load in r2=mem[i]
mov r3 0
sub1 r3 //setting r0=11111111
xor r2 r3
add1 r1 //flip mem[j]+1
add r2 r1
str r2 r0 1 //mem[72]=result, aka diffMSB
mov r0 15
b r0 //Forced branch to prevent fall thru
mov r0 8 //if we have an overflow error
shift r0 -3 //64
mov r1 7
add r0 r1//r0=71
ldr r1 r0 1 //load in r1=j
ldr r2 r0 0 //load in r2=i
ldr r1 r1 0 //load in r1=mem[j]
ldr r2 r2 0 //load in r2=mem[i]
mov r3 0
sub1 r3 //setting r0=11111111
xor r2 r3
add1 r1 //flip mem[j]+2
add r2 r1 //r2=diffMSB
str r2 r0 1 //mem[72]=result, aka diffMSB
mov r0 8 //Run By both regardless of overflow
shift r0 -3 //64
mov r1 7
add r0 r1//r0=71
ldr r1 r0 1 //load in r1=j
ldr r2 r0 0 //load in r2=i
ldr r1 r1 1 //load in r1=mem[j+1]
ldr r2 r2 1 //load in r2=mem[i+1]
sub1 r3 //setting r3=11111111
xor r1 r3
add1 r1 //flipped sign of mem[j+1]
add r1 r2 //r1 = mem[i+1]+mem[j+1] = diffLSB
ldr r2 r0 1//load r2=mem[72]
abs r2 r1 //get abs value of diffMSB, diffLSB
str r1 r0 2//store new diffLSB
str r2 r0 1//store new diffMSB//Done signs are Equal
mov r0 15
shift r0 1 //r0=30
b r0 //CONTINUE
mov r0 2//IF THE SIGNS ARE NOT EQUAL DO THIS:
add r0 r1 //r0=70 (r1 was preserved at 68)
ldr r2 r0 0 //load in i
ldr r3 r2 0//load in arr[i]
ldr r2 r2 1 //load in arr[i+1]
abs r3 r2 //get abs(arr[i].arr[i+1])
mov r1 1
add r0 r1 //r0 = 71
ldr r1 r0 0//load in j
ldr r0 r0 0//load in j
ldr r1 r1 0//load in arr[j]
ldr r0 r0 1//load in arr[j+1]
abs r1 r0 //get abs(arr[j].arr[j+1])
add r0 r2 //this addition may have had overflow
mov r3 9
shift r3 -3 //72
str r0 r3 1 //diffLSB=mem[73]=result
mov r0 1 //r0 will be overflow bit, by default set to 1
mov r2 2
bof r2 //if we have overflow, leave r0 as 1
mov r0 0 //if no overflow, make overflow bit 0
add r1 r3 //add MSB
add r1 r0 //add overflow bit
mov r3 9
shift r3 -3//72
str r1 r3 1//diffMSB=mem[72]
mov r0 15
shift r0 -1//r0=30
sub1 r0//r0=29
b r0//HELPER function, UPDATE min and max
mov r0 9 //INNER LOOP IF J<64 
shift r0 3 //r0 = 68
ldr r1 r0 3 //load r1=j
add2 r1
str r1 r0 3 //j+=2 update j
mov r2 8
shift r2 -3 //r2=64
cmp r1 r2
mov r3 8
shift r3 -4//-128
mov r1 5
add r3 r1//r3=-123
blt r3//LOOP if j < 64
mov r0 9 //OUTERLOOP IF I<64 
shift r0 -3 //r0 = 68
ldr r1 r0 2 //load r1=i
add2 r1
str r1 r0 0 //update i+=2
cmp r1 r2 //r2 will already be 64 since the only way to get here is fallthru from loop i
mov r3 8
shift r3 -4 //-128
blt r3//LOOP if i < 64
mov r3 7 //DONE WITH PROGRAM
shift r3 -4//r3=0111000=112
b r3 //Prevent fall thru into helper function
mov r0 9 //Helper function Start, max updates first
shift r0 -3 //r0=68
ldr r3 r0 0//load r3=maxMSB
mov r2 4
add r0 r2 //r0=72
ldr r2 r0 //load r2=diffMSB
cmp r2 r3
mov r1 11
blt r1 //skip to min if diffMSB<maxLSB
ldr r3 r0 1 //load r1=diffLSB
mov r1 4
sub r0 r1 //r0-=5, r0=68
ldr r1 r0 1//load r3=maxLSB
cmp r3 r1 //generate flags
mov r1 3
blt r1 //skip to min if diffLSB<maxLSB
str r3 r0 1//update maxLSB=diffLSB
str r2 r0 0//update maxMSB=diffMSB
mov r0 8//min updates
shift r0 -3//r0=64
ldr r1 r0 2//load r1=minMSB
cmp r2 r1//diffMSB will be in r2 from earlier, r1=minMSB
mov r3 12
bgt r3 //skip if diffMSB > minMSB
ldr r3 r0 3//r3=minLSB load in and compare minLSB and diffLSB
mov r1 6
add r0 r1//r0=70
ldr r1 r0 3//r1=mem[73]=diffLSB
cmp r1 r3 //generate flags
mov r3 5
bgt r3//skip if diffLSB > minLSB
mov r3 4
sub r0 r3//r0=66
str r1 1//update minLSB=diffLSB
str r2 0//update minMSB=diffMSB
mov r0 11
shift r0 -4
mov r1 12
add r0 r1 //r0=-68
b r0//Branch back up to main