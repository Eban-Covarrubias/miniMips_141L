start:
    mov r0, #0x40 // load address of n into r0
    ldr r1, [r0] // load n into r1
    mov r0, 1

    //Subtraction was used here
    saddto 1, 0, r1, r1, r0 // n-1 for the loop counter for outer loop



    //initalize min and max
    mov r2, #0x7FFF //initialized min of max 16-bit signed value
    mov r0, #0x64 // memory location 100 (min)
    str r2, r0, 00 //stores value of r2 into memory location 100

    mov r2, #0x0000 // initialized the max value
    mov r0, #0x65 // memory location 101 (max)
    str r2, r0, 00 //stores value of r2 into memory location 101

outer_loop: 
    mov r4, #0 // initalize inner loop
    mov r0, #0x40 //load the address of n into r0
    saddto 1, 0, r4, r4, r1 // adds the base address to r4

inner_loop: 
    shift r4, #0b1111 // shifts left by 1
    ldr r2, [r4] // loads value at r4 into r2
    shift r4, #0b0001 // shifts right by 1 to set it back to where it originally was
    mov r0, #0x46 //memory location 70 to save the number
    str r2, r0, 00 //stores r2 value to memory location 46
    mov r0, #0x01 // sets r0 to be 0x01
    saddto 1, 0, r2, r4, r0 //goes to the next value
    
    shift r2, #0b1111 // shifts left by 1
    ldr r3, [r2] // load next value into r3

    mov r0, #0x46 //memory location 70
    ldr r2, [r0] // load value from memory location 46 into r2
    saddto 1, 0, r2, r2, r3 //calcuates the difference
    mov r0, #0x47 //memory location 71
    str r2, r0, 00 //store the difference value into memory location 71

    mov r0, #0x00 // set r0 to 0
    blt minimum_check, r0, r2 // r0 < r2 checks to see if the difference is negative if it is it will fall thorugh to the negative section of the code


negative:
    mov r0, #0xFFFF // sets r0 to 0xFFFF so we can flip all bits
    xor r2, r2, r0 // flips all bits
    mov r0, #0b0001 // set to 1 so we can add 1 after flipping the bits
    saddto 1, 0, r2, r2, r0 //adds a bit to complete 2's complement

minimum_check:
//compares the current difference to see if it's smaller than the current minimum 

    mov r0, #0x64
    ldr r3, [r0] //load the minimum value from memory location 100
    blt max_check, r3, r2 // r3 < r2 go to next
    mov r2, r3 // update minimum
    str r2, r3, 00 //stores r2 into memory location 100 for the min value


max_check: 
//compares the current difference to see if it's larger than the current maximum

    mov r0, #0x65
    ldr r3, [r0] //loads the max value from memory locataion 101
    blt cont, r2, r3 // r2 < r3
    mov r3, r2 //updates the max
    str r2, r3, 00 //stores r2 into memory location 101 for the max value

cont:
    mov r0, #0b0001
    saddto 1, 0, r4, r4, r0 // increment inner loop index
    blt inner_loop, r4, r1 // if r4 < n-1, continue inner loop
    
    //update subtraction **double check i did the subtraction corrrectly**
    mov r0, #0b0001
    saddto 1, 0, r1, r1, r0 // decrement outer loop index

    mov r0, #0b1111 // stores -1 to r0 since we do not have a ble(branch less than equal to command) we have to make sure the we run the 0th iteration as well.
    blt outer_loop, r0, r1 // r0 < r1, continue outer loop

    //storing results (r1 can be used here since we would have finished the loops)

    ldr r0, =0x42 // load address of memory location 66

    mov r1, #0x64 //memory location for min value
    ldr r2, [r1] //loads the min value into r2
    shift r2, 1000 //shift right 8
    str r2, [r0] //store upper 8 bits to memory location 66

    saddto 0, 0, r0, r0, #1 // moves to the next memory location 67

    ldr r2, [r1] //loads the min value into r2
    shift r2, 1000
    shift r2, 1000
    shift r2, 1000 //all these shifts right 24 bits
    shift r2, 0111
    shift r2, 0111
    shift r2, 0111
    shift r2, 0011 //all these shifts left 24 bits to extract the lower 8 bits
    str r2, [r0] //stores the lower 8 bits to memory location 67

    saddto 0, 0, r0, r0, #1 // moves to next memory location 68
    
    mov r1, #0x65 //memory location for max value
    ldr r2, [r1] //loads the max value into r2

    shift r2, 1000 // shifts to the right 8 bits 
    strb r2, [r0] //store upper 8 bits to memory location 68

    saddto 0, 0, r0, r0, #1 // moves to the next memory location 69

    ldr r2, [r1] //loads the max value into r2
    shift r2, 1000
    shift r2, 1000
    shift r2, 1000 //all these shifts right 24 bits
    shift r2, 0111
    shift r2, 0111
    shift r2, 0111
    shift r2, 0011 //all these shifts left 24 bits to extract the lower 8 bits

    str r2, [r0] //stores the lower 8 bits to memory location 69


end
    
